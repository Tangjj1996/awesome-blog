# Mysql简介

关系模型由`关系数据结构`、`关系操作集合`、`关系完整性约束`三部分组成

> 关系型结构: 指的是数据以什么方式来存储，是一种二维表的形式存储
>
> 关系操作集合: 如何来关联和管理对应的存储数据，SQL指令
>
> 关系完整性约束: 数据内部有对应的关联关系，以及数据与数据之间也有对应的关联关系



> 表内约束: 对应的具体列只能放对应的数据(不能乱放)
>
> 表间约束: 自然界各实体都是有着对应的关联关系(外键)



## SQL分类

1. 数据查询语言(DQL: Data Query Language)

其语句，也被称为“数据检索语言”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL(也是所有SQL)用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY 和 HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。

> 专门用于查询数据: 代表指令为select/show

2. 数据操作语言(DML: Data Manipulation Language)\

其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动嘴哦查询语言。

> 专门用于写数据: 代表指令为insert，update和delete

3. 事务处理语言(TPL)

它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。(不是所有的关系型数据库都提供事务安全处理)

> 专门用于事务安全处理: transaction

4. 数据控制语言(DCL)

它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表个列的访问。

> 专门用于权限管理: 代表指令为grant和revoke

5. 数据定义语言(DDL)

其语句包括动词CREATE和DROP。在数据库中创建新表或删除表(CREATE TABLE或DROP TABLE)；为表加入索引等。DDL包括许多人数据目录中获得数据有关的保留字。它也是动作查询的一部分



## 登录和退出MySQL系统

通过客户端(mysql.exe)与服务器进行连接认证，就可以进行操作，通常，服务端与客户端不在用一台电脑上

- 登录

1. 找到mysql.exe(通过cmd控制台，如果在安装的时候指定了mysql.exe所在的路径为环境变量，就可以直接访问；如果没有，那么必须进入到mysql.exe所在路径)
2. 输入对应的服务器地址: -h: host -h[IP地址/域名]
3. 输入服务器中MySQL监听的端口: -P: port -P: 3306
4. 输入用户名: -u: username  -u: root
5. 输入密码: -p: password -p: root

连接认证基本语法: 

Mysql.exe/mysql -h 主机地址 -P 端口 -u 用户名 -p密码

注意事项

1. 通常端口都可以默认: mysql监听的端口一般都是3306
2. 密码的输入可以先输入-p，直接换行，然后再以密文方式输入密码

- 退出

断开与服务器的连接 --> 通常给Mysql提供的服务器数量有限，一旦客户端用完，建议就应该断开连接。

建议方式: 使用SQL提供的指令(Exit;\q;Quit;)

## Mysql服务端架构

Mysql服务端架构有以下几层构成: 

1. 数据库管理系统(最外层): DBMS，专门管理服务器端的所有内容
2. 数据库(第二层): DB，专门用于存储数据的仓库(可以有很多个)
3. 二维数据表(第三层): Table，专门用于存储具体实体的数据
4. 字段(第四层): Field，具体存储某种类型的数据(实际存储单元)

> 通过DBMS操作DB下的Table，而把真实的数据存储在Field中

数据库中常用的几个关键字

Row: 行

Column: 列（Field）

## 数据库基本操作

数据库是数据存储的最外层（最大单元）

- 创建数据库

基本语法: create database 数据库名字[库选项]

> 库选项: 数据库的相关数据
>
> - 字符集: charset 字符集，代表着当前数据库下的所有表存储的数据默认指定字符集（如果当前不指定，那么采用DBMS默认的）---> gbk 
> - 校对集: collate 校对集 ，默认指定校对集随字符集

- 显示数据库

每当用户通过SQL指令创建一个数据库，那么系统就会产生一个对应的存储数据的文件夹(data)

其实，每个数据库文件夹下都有一个opt文件，保存的是对应的数据库选项。

1. 显示所有 --> `show databases`  information_schema（保存数据库所有的结构信息，表、库），mysql（核心数据库: 权限关系）、performance_schema（效率库）、test（测试: 空库）
2. 显示部分 --> `show databases like '匹配模式'`  _: 匹配当前位置单个字符   %: 匹配指定位置多个字符

- 显示数据库创建语句

基本语法: `show create database 数据库` 

- 选择数据库 --> `use [数据库名字]`
- 修改数据库 --> 修改数据库字符集（库选项）

基本语法: alter database 数据库名字 charset = 字符集

- 删除数据库 --> `drop database 数据库名字`

## 数据表操作

- 创建数据表

1. 创建表

基本语法: create table 表名(字段名 字段类型[字段属性],字段名 字段类型[字段属性]...)

- 显示数据表

1. 显示表结构 --> 显示表中所包含的字段信息（名字，类型，属性等）

```
desc (表名)
describe (表名)
show columns from (表名)
```

2. 显示表创建语句

 查看数据表创建时的语句：此语句看到的结果已经不是用户之前自己输入的

基本语法：show create table (表名)

3. 设置表属性 ---> engine charset collate

基本语法：alter table 表名 表选项 [=] 新值 

重命名表名：rename table 旧表名 to 新表名

4. 设置表结构

```
新增表: alter table 表名 add [column] 新字段名 列类型 [列属性] [位置first/after 字段名]
修改表字段: alter table 表名 change 旧字段名 新字段名 字段类型 [列属性] [新位置]
修改字段类型(属性): alter table 表名 modify 字段名 新类型 [新属性] [新位置]
删除字段： alter table 表名 drop 字段名
```

5. 删除表 --> drop table 表名

## 数据基础操作

- 插入操作

本质含义：将数据以SQL的形式存储到指定的数据表（字段）里面

基本语法：Insert into 表名 [(字段列表)] values (对应字段列表) 

- 查询操作

1. 查询表中全部数据：select * from 表名
2. 查询表中部分字段：select 字段列表 from 表名  // 字段列表使用“,”隔开
3. 根据条件查询数据：select 字段列表/* from 表名 where 字段名 = 值

- 删除操作

基本语法：delete from 表名 [where 条件] //如果没有where条件，意味着删除所有数据

- 更新操作

更新：将数据进行修改（通常是修改部分字段数据）

基本语法：update 表名 set 字段名 = 新值 [where 条件] //如果没有where条件，那么所有的表中对应的那个字段都会被修改成统一值

## 整数类型

- Tinyint

迷你整型，系统采用一个字节来保存的整型：一个字节 = 8位，最大能表示的数值是0-255

- Smallint

小整型，系统采用两个字节来保存的整型：能表示0~65535之间

- Mediumint

中整型，采用三个字节来保存数据

- Int

整型（标准整型），采用四个字节来保存数据

- Bigint 

大整型

- 无符号标识设定

基本语法：在类型之后，加上一个unsigned

> 显示长度：指数据（整型）在数据显示的时候，到底可以显示多长位
>
> 显示长度只是代表了数据是否可以达到指定的长度，但是不会自动满足到指定长度：如果想要数据显示的时候，保持最高位（显示长度），那么还需要给字段增加一个zerofill属性
>
> Zerofill：从左侧开始填充0（左侧不会改变数值大小），所以负数的时候就不能使用zerofill，一旦使用zerofill就相当于确定该字段为unsigned

## 小数类型

专门用来存储小数的

在Mysql中将小数类型又分为两类：浮点型和定点型

- 浮点型

浮点型又称之为精度类型：是一种可能丢失精度的数据类型，数据有可能不那么准确（尤其是在超出范围的时候）

浮点型之所以能够存储较大的数值（不精确），原因就是i利用存储数据的位来存储指数

1. Float

Float又称之为单精度类型：系统提供4个字节用来存储数据，但是能表示的数据范围比整型大得多，大概是10^38；只能保证大概7个左右的精度（如果数据在7位数以内，那么基本是准确的，但是如果超过7位数，那么就不准确的）

基本语法

Float: 表示不指定小数位的浮点数

Float(M,D): 表示一共存储M个有效数字，其中小数部分占D位

2. Double

Double 双精度类型，系统用8个字节来存储数据，表示范围更大，10^308次方，但是精度也只有15位左右

- 定点数

能够保证数据精确的小数（小数部分可能不精确，超出长度会四舍五入），整数部分一定精确

Decimal --->  系统自动根据存储的数据来分配存储空间，每大概9个数就会分配四个字节来进行存储，同时小数和整数部分是分开的。

Decimal(M,D): M表示总长度，最大值不能超过65，D代表小数，不能超过30

## 时间日期类型

- Date

日期类型：系统使用三个字节来存储数据，对应的格式为：YYYY-mm-dd，能表示的范围是从1000-01-01到9999-12-12，初始值为0000-00-00

- Time

时间类型：能够表示某个指定的时间，但是系统同样是提供3个字节来存储，对应的格式为：HH:ii:ss，但是mysql中的time类型能够表示时间范围要大的多，能表示从-838:59:59~838:59:59，在mysql中具体的用处是用来描述时间段

- Datetime

日期时间类型：就是将前面的date和time合并起来，表示的时间，使用8个字节存储数据，格式为YYYY-mm-dd HH:ii:ss，能表示的区间1000-01-01 00:00:00 到 9999-12-12 23:59:59，其可以为0值: 0000-00-00 00:00:00

- Timestamp

时间戳类型：mysql中的时间戳只是表示从格林威治时间开始，但其格式依然是：YYYY-mm-dd HH:ii:ss

- Year

年类型：占用一个字节来保存，能表示1900~2155年，但是year有两种数据插入方式：0~99和四位数的具体年

year进行两位数插入的时候，有一个区间划分，零界点为69和70，当输入69以下，那么系统时间为20+数字，如果是70以上，那么系统时间为19+数字

## 字符串型

- char ---> 定长字符：指定长度之后，系统一定会分配指定的空间用于存储数据

  基本语法：char(L)，L代表字符数（中文与英文字母一样），L长度为0到255

- varchar ---> 变长字符：指定长度之后，系统会根据实际存储的数据来计算长度，分配合适的长度（数据没有超出长度）

  基本语法：Varchar(L)，L代表字符数，L的长度理论值位0到65535

  因为varchar要记录数据长度（系统根据数据长度自动分配空间），所以每个varchar数据产生后，系统都会在数据后面增加1~2个字节的额外开销：是用来保存数据所占用的空间长度，如果数据本身小于127个字符，额外开销一个字节；如果大于127个，就开销两个字节

- Text 

  文本类型：本质上Mysql提供了两种文本类型

  Text: 存储普通的字符文本

  Blob: 存储二进制文本（图片，文件），一般都不会使用blob来存储文件本身，通常是使用一个链接来指向对应的文件本身

  系统中提供了四种text

  ```
  Tinytext: 系统使用一个字节来保存，实际能够存储的数据位：2^8+1
  Text: 使用两个字节保存，实际存储为：20^16+2
  Mediumtext: 使用三个字节保存，实际存储为： 20^24+3
  Longtext: 使用四个字节来保存，实际存储为：20^32+4
  
  注意：
  1. 在选择对应的存储文本的时候，不用刻意去选择text类型，系统会自动根据存储的数据长度来选择合适的文本类型。
  2. 在选择字符存储的时候，如果数据超过255个字符，那么一定选择text存储
  ```

- Enum

  枚举类型：在数据插入之前，先设定几个项，这几个项就是可能最终出现的数据结果

  如果确定某个字段的数据只有那么几个值：如性别、男、女、保密，系统就可以在设定字段的时候规定当前字段只能存放固定的几个值：使用枚举

  基本语法：enum(数据1,数据2...)

  系统提供了1到2个字节来存储枚举数据：通过计算enum列举的具体值来选择实际的存储空间：如果数据值列表在255以内，那么一个字节就够，如果超过255但是小于65535，那么系统采用两个字节

  枚举enum的存储原理：实际上字段上所存储的值并不是真正的字符串，而是字符串对应的下标：当系统设定枚举类型的时候，会给枚举中每个元素定义一个下标，这个下标规则

  特性：在mysql中系统是自动进行类型转换的，如果数据碰到“+、-、*、/”系统就会自动将数据转换成数值，而普通字符串换成数值为0

- Set

  集合：是一种将多个数据选项可以同时保存的数据类型，本质是将指定的项按照对应的二进制来进行控制，1表示该项被选中，0表示该项未被选中。

  基本语法：set('值1','值2','值3'...)

  系统为set提供了多个字节进行保存，但是系统会自动计算来选择具体的存储单元

  1个字节：set只能由8个选项

  2个字节：set只能有16个选项

  3个字节：set只能表示24个选项

  8个字节：set可以表示64个选项

  Set和Enum一样，最终存储到数据字段中的依然是数字而不是真实的字符串

## 列属性

- Null属性

  在设计表的时候尽量不要让数据为空

  Mysql的记录长度为65535个字节，如果一个表中有字段允许为Null，那么系统会设计保留一个字节来存储NULL，最终有效存储长度为65534个字节

- Default 关键字的另外一层使用：显示地告知字段使用默认值 ---> 在进行数据插入的时候，对字段值直接使用default

- 列描述

  comment，专门用于给开发人员进行维护的一个个注释说明

  基本语法：comment '字段描述'

## 主键

> 主要的键，primary key，在一张表中，有且只有一个字段，里面的值具有唯一性

- 创建主键

  - 随表创建

    1. 直接在需要当作主键的字段之后增加primary key 属性来确定主键
    2. 在所有字段之后增加primary key 选项，primary key(字段信息)

  - 表后增加

    基本语法：alter table 表名 add primary key(字段)

- 查看主键

  1. 查看表结构  ---> desc 表名 
  2. 查看表的创建语句 ---> show create table 表名

- 删除主键

  ```
  alter table 表名 drop primary key 
  ```

- 复合主键

- 主键约束

  主键一旦增加，那么对应的字段有数据要求

  1. 当前字段对应的数据不能为空
  2. 当前字段对应的数据不能有任何重复

- 主键分类

  主键分类采用的是主键所对应的字段业务意义分类

  业务主键：主键所在的字段，具有业务意义（学生ID，课程ID）

  逻辑主键：自然增长的整型（应用广泛）

## 自动增长

> auto increment，当给定某个字段该属性之后，该列的数据在没有提供确定数据的时候，系统会根据之前已经存在的数据进行自动增长，填充数据，通常用于逻辑主键

- 原理

  1. 在系统中有维护一组数据，用来保存当前使用了自动增长属性的字段，记住当前对应的数据值，再给定一个指定的步长
  2. 当用户进行数据插入的时候，如果没有给定值，系统在原始值上再加上步长变成新的数据
  3. 自动增长的触发   ---> 给定属性的字段没有提供值
  4. 自动增长只适用于数值

- 使用自动增长

  基本语法：在字段之后增加一个属性auto_increment

- 修改自增长

  1. 查看自增长：自增长一旦触发使用之后，会自动地在表选项中增加一个选项（一张表最多只能拥有一个自增长）
  2. 表选项可以通过修改表结构来实现

- 删除自增长

  字段属性之后不再保留auto_increment，当用户修改自增长所在字段时，如果没有看到auto_increments属性，系统会自动清楚该自增长

  > alter table 表名 modify 字段 类型

- 初始设置

  在系统中，有一组变量用来维护自增长的初始值和步长

  > show variables like 'auto_increment%';

- 细节问题

  1. 一张表只有一个自增长：自增长会上升到表选项中
  2. 如果数据插入中没有触发自增长

## 唯一键

> unique key 用来保证对应的字段中的数据唯一的
>
> 主键也可以用来保证字段数据唯一性，但是一张表只有一个主键
>
> 唯一键在一张表中可以有多个
>
> 唯一键允许字段数据为NULL，NULL可以有多个（NULL不参与比较）

- 创建唯一键

  创建唯一键与创建主键非常类似

  1. 直接在表字段之后增加唯一键标识符：unique[key]
  2. 在所有的字段之后使用unique key(字段列表)
  3. 在创建完表之后也可以增加唯一键

  > alter table 表名 add unique key(字段列表)


- 查看唯一键

  唯一键是属性，可以通过查看表结构来实现

  唯一键效果：在不为空的情况下，不允许重复

- 删除唯一键

  一个表中允许存在多个唯一键：假设命令为主键一样 ---> alter table 表名 drop unique key;(这是错误做法)

  index 关键字：提升查找效率

  删除的基本语法：alter table 表名 drop index 唯一键名字;

## 表关系

> 表与表之间（实体）有什么样的关系，每种关系应该如何设计表结构。

- 一对一

  一张表中的一条记录与另外一张表中最多有一条明确的关系 ---> 通常，此设计方案保证两张表中使用同样的主键即可

- 一对多（多对一）

  通常一对多的关系设计的方案，在“多”关系的表中去维护一个字段，这个字段是“一”关系的主键

- 多对多

  一张表中的一条记录在另外一张表中可以匹配到多条记录，反过来也一样

  多对多的关系如果按照多对一的关系维护：就会出现一个字段中有多个其他表的主键，在访问的时候就会带来不便

  既然通过两张表自己增加字段解决不了问题，那么就通过第三张表来解决

  多对一解决方案：增加一个中间表，让中间表与对应的其他表形成两个多对一的关系，多对一的解决方案是在“多”表中增加“一”表对应的主键字段

## 高级数据操作

- 新增数据

  1. 多数据插入

     只要写一次insert指令，但是可以直接插入多条记录

     基本语法：insert into 表名 [(字段列表)] values(),(),(),()

  2. 主键冲突

     在有的表中，使用的是业务主键（字段有业务含义），但是在进行数据插入的时候，又不确定数据表中是否已经存在对应的主键

     主键冲突的解决方案：

     - 类似插入数据语法，如果插入的过程中主键冲突，那么采用更新方法

       insert into 表名 [(字段列表)] values(值列表) on duplicate key update 字段 = 新值

     - 主键冲突替换，当主键冲突之后，干掉原来的数据，重新插入进去

       replace into [(字段列表)] values(值列表)

  3. 蠕虫复制

     一分为二，成倍增加，从已有的数据中获取数据，并且将获取到的数据插入到数据表中。

     insert into 表名 [(字段列表)] select */字段列表 from 表

- 更新数据

  1. 在更新数据的时候，特别要注意，通常一定要跟随条件更新

     update 表名 set 字段名 = 新值 where 判断条件;

  2. 如果没有条件，是全表更新数据。但是可以使用limit来显示更新的数量

     update 表名 set 字段名 = 新值 [where 判断条件] limit 数量;

- 删除数据

  1. 删除数据的时候尽量不要全部删除，应该使用where进行判定
  2. 删除数据的时候可以使用limit来限制要删除的具体数量

  delete 删除数据的时候无法重置auto_increment

  Mysql有一个能够重置表选项中的自增长的语法 ---> truncate 表名

- 查询数据（where）

  Select select 选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制;

  1. Select 选项：系统该如何对待查询得到的结果

     All：默认的，表示保存所有的记录

     Distinct：去重，去除重复的记录，只保留一条（所有的字段都相同）

  2. 字段列表：有时候需要从多张表中获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段命名成不同名，---> 别名alias

     基本语法：字段名[as] 别名

  3. from数据源

     from是为了前面的查询提供数据：数据源只要是一个符合二维表结构的数据即可。

     - 单表数据

     - 多表数据

       从多张表获取数据，基本语法：from 表1,表2...

       结果：两张表的记录数相乘，字段数拼接

       本质：从第一张表取出一条记录，去拼凑第二张表的所有记录，保留所有结果。得到的结果称为笛卡尔积

     - 动态数据

       from后面跟的数据不是一个实体表，而是一个从表中查询出来得到的二维结果表（子查询）

       基本语法：from (select 字段列表 from 表名) as

- where 子句

  用来从数据表获取数据的时候，然后进行条件筛选

  数据获取原理：针对表去对应的磁盘处获取所有的记录（一条条），where的作用就是在拿到一条结果就开始进行判断，判断是否符合条件：如果符合就保存下来，如果不符合直接舍弃（不存到内存中）

  Where是通过运算符进行结果比较来判断数据

- Group by 子句

  Group by 表示分组的含义：根据指定的字段，将数据进行分组，分组的目的是为了统计

  1. 分组统计

     Group by 是为了分组后进行数据统计，如果只是想看数据显示，没有含义；group by 将数据按照指定的字段分组之后，只会保留每组的第一条记录

     利用一些统计函数（聚合函数）

     count()：统计每组中的数量，如果统计目标是字段，那么不统计为空NULL字段

     avg()：求平均值

     sum()：求和

     max()：求最大值

     min()：求最小值

  2. 多分组

     将数据按照某个字段进行分组之后，对已经分组的数据进行再次分组

     基本语法：group by 字段1,字段2; 

  3. 分组排序

     Mysql中，分组默认有排序的功能：按照分组字段进行排序，默认是升序

     基本语法： group by 字段 [asc|desc] , 字段[asc|desc]

  4. 回溯统计

     当分组进行多分组之后，往上统计的过程中，需要进行层层上报，将这种层层上报统计的过程称之为回溯统计：每一次分组向上统计的过程都会产生一次新的统计数据，而且当前数据对应的分组字段为NULL

     基本语法：group by 字段 [asc|desc] with rollup; 

- Having 子句

  having的本质和where一样，是用来进行数据条件筛选

  1. having是在group by 子句之后，可以针对分组数据进行统计筛选，但是where不行

     where不能使用聚合函数，聚合函数是用在group by分组的时候，where已经运行完毕；having在group by分组之后，可以使用聚合函数或者字段别名（where是从表中取出数据，别名是在数据进入内存之后才有的）

- Order by 子句

  order by排序：根据校对规则对数据进行排序

  基本语法：order by 字段 [asc|desc] 

  order by也可以像group by 一样进行多字段排序，先按照第一个字段进行排序，然后再按照第二个字段进行排序

  order by 字段1 规则,字段2 规则

- Limit 子句

  Limit限制子句：主要是用来限制记录数量获取

  基本语法：limit 数量;

  limit 通常在查询的时候如果限定为一条记录的时候，使用的比较多：有时候获取多条记录并不能解决业务问题，但是会增加服务器的压力

  分页

  利用limit来限制获取指定区间的数据

  基本语法：limit offset,length; //offset 偏移量：从哪开始，length就是具体的获取多少条记录

  Mysql中记录的数据从0开始

  Limit 0,2;表示获取前两条记录

  注意：limit后面的length表示最多获取对应的数量，但是如果数量不够，系统不会强求

- 查询中的运算符

  1. 算数运算符 、

     +、-、*、/、%

     基本算术运算，通常不在条件中使用，而是在select中使用
     
  2. 比较运算符
  
  3. 逻辑运算符
  
     and、or、not
  
  4. In运算符
  
     In：在什么里面，是用来替代=，当结果不是一个值，而是一个结果集的时候
  
     基本语法：in(如果1,如果2,如果3...)，只要当前条件在结果集中出现过，那么就成立
  
  5. Is运算符
  
     Is是朱门用来判断字段是否为NULL的运算符
  
     基本语法：is null/is not null
  
  6. Like运算符
  
     是用来模糊匹配
  
     基本语法：like  ‘匹配模式’
  
     匹配模式中，有两种占位符
  
     -：匹配对应的单个字符
  
     %:：匹配多个字符

## 联合查询

- 基本概念

  是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为UNION或UNION ALL。

  联合查询：将多个查询的结果合并到一起（纵向合并）---> 字段数不变，多个查询的记录数合并

- 应用场景

  1. 将同一张表中不同的结果（需要对应多条查询语句来实现），合并到一起展示数据
  2. 最常见：在数据量大的情况下，会对表进行分表操作，需要对每张表进行部分数据统计，使用联合铲鲟来将数据存放到一起显示。

- 基本语法

  Select 语句

  Union [union 选项]

  Select 语句;

  Union 选项：与select 选项基本一样

  Distinct：去重，去掉完全重复的数据（默认的）

  All：全部

  注意细节：union理论上只要保证字段数一样，不需要每次拿到的数据对应的字段类型一致，永远只保留第一个select语句对应的字段名字。

- Order by 的使用

  在联合查询中，如果要使用order by，那么对应的select语句必须使用括号括起来

  order by 在联合查询中若要生效，必须和使用limit，而limit后面必须跟对应的限制数量（通常可以使用一个较大的值  --> 大于对应表的记录数）

## 连接查询

> 将多张表连到一起进行查询（会导致记录数行和字段数列发生改变）

- 连接查询的意义

  在关系型数据库设计过程中，实体（表）与实体之间是存在很多联系的。在关系型数据库表的设计过程中，遵循着关系来设计：一对一，一对多和多对多，通常在实际操作的过程中，需要利用这层关系保证数据的完整性

- 连接查询分类

  - 交叉连接

  > 将两张表的数据与另外一张表彼此交叉

  原理：

  1. 从第一张表依次取出每一条记录
  2. 取出每一条记录之后，与另外一张表的全部记录挨个匹配
  3. 没有任何匹配条件，所有的结果都会进行保留
  4. 记录数 = 第一张表记录数 * 第二张表记录数;字段数 = 第一张表字段数 + 第二张表字段数 (笛卡尔积)

  语法：

  表1 cross join 表2;

  应用：

  交叉连接产生的结果是笛卡尔积，没有实际应用

  - 内连接

  > inner join，从一张表中取出所有的记录去另外一张表中匹配：利用匹配条件进行匹配，成功了则保留，失败了放弃。

  原理：

  1. 从第一张表中取出一条记录，然后去另外一张表中进行匹配
  2. 利用匹配条件进行匹配
  3. 因为表的设计通常容易产生同名字段，尤其是ID，所以为了避免重名出现错误，通常使用表名.字段名，来确保唯一性
  4. 通常，如果条件中使用到对应的表名，而表名通常比较长，所以通过表别名
  5. 内连接匹配的时候，必须保证匹配到才会保存
  6. 内连接因为不强制必须使用匹配条件（on）因此可以在数据匹配完成之后，使用where条件来限制，效果与on一样（建议使用on）

  应用：

  内连接通常是在对数据有精确要求的地方使用，必须保证两种表中都能进行数据匹配。

  基本语法：表1 [inner] join 表2 on 匹配条件;

  - 外连接：左外连接（左连接）和右外连接（右连接）

    > outer join，按照某一张表作为主表（表中所有记录在最后都会保留），根据条件去连接另外一张表，从而得到目标数据。

    外连接分为两种：左外连接（left join），右外连接（right join）

    左连接：左表是主表

    右连接：右表是主表

    原理：

    1. 确定连接主表：左连接就是left join左边的表为主表；right join就是右边为主表
    2. 拿主表的每一条记录，去匹配另外一张表（从表）的每一条记录
    3. 如果满足匹配条件：保留；不满足即不保留
    4. 如果主表记录在从表中一条都没有匹配成功，那么也要保留该记录：从表对应的字段值都未NULL

    语法：

    基本语法

    左连接：主表left join 从表 on 连接条件

    右连接：从表right join 主表 on 连接条件

    左连接对应的主表数据在左边；右连接对应的主表数据在右边，主表记录一定保存，从表没有数据对应，字段为NULL

    应用：

    非常常用的一种获取的数据方式：作为数据获取对应的主表以及其他数据（关联）

  - 自然连接

    基本语法：表名1 natural join 表名2

- Using 关键字

  是在连接查询中用来代替对应的on关键字，进行条件匹配

  原理：

  1. 在连接查询时，使用on的地方用using代替
  2. 使用using的前提时对应的两张表连接的字段是同名（类似自然连接自动匹配）
  3. 如果使用using关键字，那么对应的同名字段，最终在结果中只会保留一个

  语法：

  基本语法：表1 [inner] join 表2 using(同名字段列表);

- 子查询

  > sub query 子查询是一种常用计算机语言select-sql语言中嵌套查询下层的程序模块。当一个查询时另外一个查询的条件时，称之为子查询，指的是在一条select语句中，嵌入了另外一条select语句，那么被嵌入的select语句称之为子查询语句

  > 主查询：主要的查询对象，第一条select语句，确定的用户所有获取数据目标（数据源），已经要具体得到的字段信息

  > 子查询和主查询的关系
  >
  > 1. 子查询时嵌入到主查询中
  > 2. 子查询的辅助主查询：要么作为条件，要么作为数据源
  > 3. 子查询其实可以独立存在：是一条完整的select语句

- 子查询分类

  1. 按功能分

     标量子查询：子查询返回的结果是一个数据（一行一列）

     - 概念

       子查询得到结果是一个数据（一行一列）

     - 语法

       基本语法：select * from 数据源 where 条件判断 =/<> (select 字段名 from 数据源 where 条件判断)

     列子查询：返回的结果是一列（一列多行）

     - 概念

       列子查询：子查询得到的结果是一列数据（一列多行）

     - 语法

       主查询 where 条件 in (列子查询)

     行子查询：返回的结果是一行（一行多列）

     - 概念

       行子查询：子查询返回的结果是一行多列

     - 行元素

       行元素：字段元素是指一个字段对应的值，行元素对应的就是多个字段，多个字段合起来作为一个元素参与运算，把这种情况称之为行元素。

     - 语法

       基本语法： 主查询 where 条件[(构造一个行元素)] = (行子查询)

     表子查询：返回的结果是多行多列（多行多列）

     - 概念

       子查询返回的结果是多行多列，表子查询与行子查询非常相似，只是行子查询需要产生行元素，而表子查询没有。

       行子查询是用于where条件判断：where子查询

       表子查询是用于from数据源：from子查询

     - 语法

       基本语法： Select 字段表 from (表子查询) as 别名 [where] [group by] [having] [order by] [limit] 

     Exists子查询：返回的结果1或者0（类似布尔操作）

     - 概念

       Exists子查询：查询返回的结果只有0或者1，1代表成立，0代表不成立

     - 语法

       基本语法：where exists(查询语句); // exists 就是根据查询得到的结果进行判断 ---> 如果结果存在，那么返回1，否则返回0

  2. 按位置分

     Where 子查询：子查询出现的位置在where条件中

     From 子查询：子查询出现的位置在from数据源中（做数据源）

## 整库数据备份与还原

> 整库数据备份也叫SQL数据备份：备份的结果都是SQL指令

在Mysql中提供了一个专门用于备份SQL的客户端: mysqldump.exe

- 应用场景

  SQL备份是一种mysql非常常见的备份与还原方式，SQL备份不只是备份数据，还备份对应的SQL指令（表结构）：即便是数据库遭到毁灭性的破坏（数据库被删），那么利用SQL备份依然可以实现数据还原

  SQL备份因为需要备份结构，因此产生的备份文件特别大，因此不适合特大型数据备份，也不适合数据变换频繁型数据库备份。

- 应用方案

  - SQL备份

    SQL备份用到的是专门的备份客户端，因此还没与数据库服务器进行连接

    基本语法：mysqldump/mysqldump.exe     -hPup   数据库名字[表1 [表2...]]   >  备份文件地址 

    备份可以有三种形式：

    1. 整库备份（只需要提供数据库名字）、
    2. 单表备份：数据库后面跟一张表
    3. 多表备份：数据库后面跟多张表

  - 数据还原

    Mysql提供了多种方式来实现：两种

    Mysql备份的数据中没有关于数据库本身的操作，都是针对表级别的操作：当进行数据（SQL还原），必须指定数据库

    1. 利用mysql.exe客户端：没有登录之前，可以直接用该客户端进行数据还原，Mysql.exe -hPup 数据库 < 文件位置
    2. 在Sql指令，提供了一种导入SQL指令的方式  --->   Source  SQL文件位置;
    3. 人为操作：打开备份文件，复制所有SQL指令，然后到mysql.exe客户端去粘贴执行

## 用户权限管理

> 在不同的项目中给不同的角色（开发者）不同的操作权限，为了保证数据库数据的安全
>
> 通常，一个用户的密码不会长期不变，所以需要经常性地变更数据库用户密码来确保用户本身安全（mysql客户端用户）

- 用户管理

  Mysql需要客户端进行连接认证才能进行服务器操作：需要用户信息，Mysql中所有的用户信息都是保存在mysql数据库下的user表中

  默认的，在安装Mysql的时候，如果不选择创建匿名用户，那么意味着所有的用户只有一个  ---> root超级用户

  在mysql中，是由对应的Host和User共同组成主键来区分用户。

  User：代表用户的用户名

  Host：代表本质是允许访问的客户端（IP或者主机地址）。如果host使用*代表所有的用户（客户端）都可以访问

  - 创建用户

    理论上可以采用两种方式创建用户：

    1. 直接使用root用户在mysql.user表中插入记录（不推荐）
    2. 专门创建用户的SQL指令

    基本语法：create user 用户名 identified '明文密码';

    用户：用户名@主机地址

    主机地址：''/'%'

  - 删除用户

    注意：mysql中user是带着host本身的（具有唯一性）

    基本语法：drop user  用户名@host;

  - 修改用户密码

    Mysql中提供了多种修改的方式：基本上都必须使用对应提供的一个系统函数 ---> password()，需要靠该函数对密码进行加密处理

    1. 使用专门的修改密码的指令

       基本语法：set password for 用户 = password ('新的明文密码');

    2. 使用更新语句update来修改表

       基本语法：update mysql.user set authentication_string= password('新的明文密码') where user = '' and host = '';

- 权限管理

  > 在mysql中将权限管理分为三类：
  >
  > 1. 数据权限：增删改查(select\update\delete\insert)
  > 2. 结构权限：结构操作(create\drop)
  > 3. 管理权限：权限管理(create user\grant\revoke)   通常只给管理员权限

  - 授予权限：grant

    将权限分配给指定的用户

    基本语法：grant 权限列表 on 数据库.表名 to 用户;

    权限列表：使用逗号分隔，但是可以使用all privileges代表全部权限

    数据库.表名：可以是单表（数据库名字.表名），可以是具体某个数据库（数据库），也可以整库（*）

    用户被分配权限以后不需要退出就可以看到效果

    具体权限查看：单表权限只能看到数据库中的一张表  

  - 取消权限：revoke

    权限回收：将权限从用户手中收回

    基本语法：revoke   权限列表/all privileges  on   数据库/\*.表/* from 用户;

    权限回收，同样不需要刷新，用户马上响应

  - 刷新权限：flush

    Flush：刷新，将当前对用户的权限操作，进行一个刷新，将操作的具体内容同步到对应的表中

    基本语法：flush privileges;

- 密码丢失的解决方案

  如果忘记了root用户密码，就需要去找回或者重置root用户密码

  1. 停止服务
  2. 重新启动服务：mysqld.exe --skip-grant-tables //启动服务器但是跳过权限（8.0以上版本用 `mysqld --console --skip-grant-tables --shared-memory`）
  3. 当前启动的服务器没有权限概念：非常危险，任何客户端，不需要任何用户信息都可以直接登录，而且是root权限；新开客户端，使用mysql.exe登录即可
  4. 修改root用户的密码，指定用户名@host
  5. 赶紧关闭服务器，重启服务

## 外键

- 外键概念

  如果公共关键字再一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。外键又称作外关键字。

  外键：foreigin key

  一张表（A）中有一个字段，保存的值指向另外一张表（B）的主键

- 外键的操作

  - 增加外键

    Mysql中提供了两种方式增加外键

    1. 方案一：在创建表的时候增加外键（类似主键） ---> [constraint \`外键名`] foreign key(外键字段) references 主表(主键);

       MUL：多索引，外键本身是一个索引，外键要求外键字段本身也是一种普通索引

    2. 方案二：在创建表后增加外键

       alter table 从表 add[constraint \`外键名`] foreign key(外键字段) references 主表(主键);

  - 修改&删除外键

    外键不允许修改，只能先删除后增加

    基本语法：alter table 从表 drop foreign key  外键名字

    外键不能删除产生的普通索引，只会删除外键

    如果想删除对应的索引：alter table 表名 drop index 索引名字;

  - 外键基本要求

    1. 外键字段需要保证与关联的主表的主键字段类型完全一致
    2. 基本属性也要相同
    3. 如果实在表后增加外键，对数据还有一定的要求（从表数据与主表的关联关系）
    4. 外键只能使用Innodb存储引擎：myisam不支持

- 外键约束

  > 外键约束：通过建立外键关系之后，对主表和从表都会有一定的数据约束效率

  - 约束的基本概念

    当一个外键产生时：外键所在的表（从表）会受制于主表数据的存在从而导致数据不能进行某些不符合规范的操作（不能插入主表不存在的数据）；

    如果一张表被其他表外键引入，那么该表的数据操作就不能随意：必须保证从表数据的有效性（不能随便删除一个被从表引入的记录）

  - 外键约束的概念

    可以在创建外键的时候，对外键约束进行选择性的操作

    基本语法：add foreign key(外键字段) reference 主表(主键) on 约束模式;

    约束模式有三种

    district(严格模式)、cascade(级联模式)、set null(置空模式)

    外键约束主要约束的对象是是主表操作：从表就是不能插入主表不存在的数据

    通常在进行约束的时候，需要指定操作：update和delete

    常用的约束模式：on update cascade,on delete set null,更新级联，删除置空

  - 约束作用

    保证数据的完整性：主表与从表的数据要一致

    正是因为外键有非常强大的数据约束作用，而且可能导致数据在后台变化的不可控。导致程序在进行设计开发逻辑的时候，没有办法去很好地把握数据（业务），所以外键比较少使用。

## 视图基本操作

- 创建视图

  视图的本质是SQL指令（select语句）

  基本语法：create view 视图名字 as select指令; // 可以是单表数据，也可以是连接查询，联合查询或者子查询

  查看视图结构：视图本身是虚拟表，所以关于表的一些操作都适用于视图、

  show tables/show create table[view]/desc 视图名字

- 使用视图

  视图是一张虚拟表：可以直接把视图当作”表“操作，但是视图本身没有数据，是临时执行select语句得到对应的结果。视图主要用于查询操作

  基本语法：select 字段列表 from 视图名字

- 修改视图

  本质是修改视图对应的查询语句

  基本语法：alter view 视图名字 as 新select指令;

- 删除视图

  基本语法：drop view 视图名字;

## 事务安全

- 事务概念

  事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元（unit）。事务通常由高级数据库操作语言或编程语言书写的用户程序的执行所引起。事务由事务开始(begin transaction)和事务结束（end transaction）之间执行的全体操作组成。

- 事务基本原理

  基本原理：Mysql允许将事务统一进行管理（存储引擎INNODB），将用户所作的操作，暂时保存起来，不直接放到数据表（更新），等到用于确认结果之后再进行操作。

  事务在mysql中通常是自动提交的，但是也可以使用手动事务。

- 自动事务

  autocommit，当客户端发送一条SQL指令（写操作：增删改）给服务器的时候，服务器在执行之后，不同等待用户反馈结果，会自动将结果同步到数据表。

- 手动事务

  > 不管是开始还是结束，都需要手动发送事务操作指令来实现

  手动事务对应的命令：

  1. start transaction;  //开启事务：从这条语句开始，后面的所有语句都不会直接写入到数据表（保存在事务日志中）
  2. 事务处理：多个写指令构成
  3. 事务提交：commit/rollback，到这个时候所有的事务才算结束

## 变量

Mysql本质是一种变成语言，需要很多变量来保存数据。Mysql中很多的属性控制都是通过mysql中固有的变量来实现的。

- 系统变量

  系统内部定义的变量，系统变量针对所有用户（MySQL客户端）有效

  查看系统所有变量 show variables [like 'pattern'];

  Mysql允许用户使用select查询变量的数据值（系统变量）

  基本语法：select @@变量名;

  修改系统变量：分为两种修改方式

  1. 局部修改（会话级别）：只针对当前自己客户端当此连接有效

     基本语法：set 变量名 = 新值;

  2. 全局修改：针对所有的客户端，”所有时刻“都有效

     基本语法：set global 变量名 = 值; || set @global.变量名= 值;

     全局修改之后哦：所有连接的客户端并没有发生改变，全局修改只针对新客户端生效（正在连着的无效）

- 会话变量

  会话变量也称为用户变量，会话变量跟mysql客户端是绑定的，设置的变量只对当前用户使用的客户端有效

  定义用户变量：set @变量名=值;

  在mysql中因为没有比较符号==，所以是用=代替比较符号：有时赋值会报错，mysql为了避免系统分不清是赋值还是比较：特定增加一个变量的赋值符号，:=

  set @变量名 := 值;

  Mysql是专门存储数据的：允许将数据从表中取出存储到变量中，查询得到的数据必须只能是一行数据（一个变量对应一个字段值），Mysql没有数组。

  1. 赋值且查看赋值过程：select @变量 1 := 字段 1,@变量2 := 字段 2 from 数据表 where 条件
  2. 只赋值，不看过程：select 字段1,字段2...from 数据源 where 条件 into @变量1,@变量2...

- 局部变量

  作用范围在begin到end语句块之间。在该语句块里设置的变量，declare语句专门用于定义局部变量

  1. 局部变量是使用declare关键字声明
  2. 局部变量declare语句出现的位置一定是在begin和end之间（begin end是在大型语句块中使用：函数/存储过程/触发器）
  3. 声明语法：declare 变量名 数据类型 [属性];

## 流程结构

> 代码的执行顺序

- If分支

  基本语法：if在Mysql中由两种基本用法

  1. 用在select查询当中，当作一种条件来进行判断  ---> if (条件,'真','假') 
  2. 用在复杂的语句块中（函数/存储过程/触发器） ---> if 条件表达式 then 满足条件要执行的语句; end if;

  复合语法

  > 代码的判断存在两面性，两面都有对应的代码执行。

  基本语法：if 条件表达式 then 满足条件要执行的语句; else 不满足条件要执行的语句; end if;

## While 循环

- 基本语法

  循环体都是需要在大型代码块中使用

  while 条件 do 要循环执行的代码 end while

- 结构标识符

  > 为某些特定的结构进行命名，然后为的是在某些地方使用名字

  标识名字: while 条件 do 循环体 end while[标识名字];

  标识符的存在主要是为了循环体中使用循环控制。在mysql中没有continue和break，有自己的关键字替代：

  iterate: 迭代，以下的代码不执行，重新开始循环(continue)

  leave: 离开，整个循环终止(break)

  标识名字: while 条件 do if 条件判断 then 循环控制; iterate/标识名字; end if; 循环体 end while[标识名字]

## 函数

在mysql中，函数分为两类：系统函数（内置函数）和自定义函数

不管是内置函数还是用户自定义函数，都是使用select 函数名（参数列表）;

- 内置函数

  1. 字符串函数

     Char_length()：判断字符串的字符数

     Length()：判断字符串的字节数（与字符集）

     Concat()：连接字符串

     Instr()：判断字符在目标字符串中是否存在，存在返回其位置，不存在返回0

     Lcase()：全部小写

     Left()：从左侧开始截取字符串到指定位置

     Ltrim()：消除左边对应的空格

     Mid()：从中间指定位置开始截取，如果不指定长度，直接到最后

  2. 时间函数

     Now()：返回当前时间，日期

     Curdate()：返回当前日期

     Curtime()：返回当前时间

     Datediff()：判断两个日期之间的天数差距，参数日期必须使用字符串格式（用引号）

     Date_add(日期,interval 时间数字 type)：进行时间的增加 type可选值：day/hour/minute/second

     Unix_timestamp()：获取时间戳

     Form_unixtime()：将指定时间戳转换成日期

  3. 数学函数

     Abs()：绝对值

     Ceiling()：向上取整

     Floor()：向下取整

     Pow()：求指数，谁的多少次方

     Rand()：获取一个随机数（0-1之间）

     Round()：四舍五入函数

  4. 其他函数

     Md5()：对数据进行md5加密（mysql中的md5与其他任何地方md5加密出来的内容是完全相同的）

     Version()：获取版本号

     Database()：显示当前所在数据库

     UUID()：生成一个唯一标识符（自增长）：自增长是单表唯一，UUID是整库（数据唯一同时空间唯一）

- 自定义函数

  > 函数：实现某种功能的语句块（由多条语句组成）

  1. 函数内部的每条指令都是独立的个体，需要符合语句定义规范，需要语句结束分号

  2. 函数是一个整体，而且函数是在调用的时候才会被执行，那么当设计函数的时候，意味着整体不能被中断

  3. Mysql一旦见到语句结束符分号，就会自动开始执行

     解决方案：在定义函数之前，尝试修改临时的语句结束符

     基本语法：delimiter

     修改临时语句结束符：delimiter 新符号[可以使用系统非内置即可]

     中间为正常SQL指令：使用分号结束（系统不会执行，不认识分号）

     使用新符号结束

     修改回语句结束符：delimiter

     - 创建函数

       自定义函数包含几个要素：function 关键字，函数名，参数（形参和实参[可选]），确认函数返回值类型，函数体，返回值

       函数定义基本语法：

       Create function 函数名（形参） returns 返回值类型

       Begin 函数体... End 语句结束符

       （并不是所有的函数都需要begin end：如果函数体本身只有个一条指令return，那么可以省略）

       形参：在Mysql中需要为函数的形参指定数据类型（形参本身可以有多个）

       基本语法：变量名 字段类型

     - 查看函数

       可以通过查看function状态，查看所有函数

       show function status [like 'pattern'];

     - 调用函数

       自定义函数的调用与内置函数的调用是一样的：select 函数名(实参列表);

     - 删除函数

       drop function 函数名

     - 注意事项

       1. 自定义函数是属于用户级别的：只有当前客户端对应的数据库中可以使用
       2. 可以在不同的数据库下看到对应的函数，但不可以调用
       3. 自定义函数：通常是为了将多行代码集合到一起解决一个重复性的问题
       4. 函数因为必须规范返回值：那么在函数内部不能使用select指令 ---> 一旦执行就会得到一个结果（result set）：select 字段 into @变量;(唯一可用)

## 变量作用域

> 变量能够使用的区域范围

- 局部作用域

  使用declare关键字声明（在结构体内：函数/存储过程/触发器），而且只能在结构体内部使用

  declare关键字声明的变量没有任何修饰，就是普通字符串，如果在外部访问该变量，系统会自动认为是字段
  
- 会话作用域

  用户定义的：使用@符号定义的变量，使用set关键字

  会话作用域：在当前用户档次连接有效，只要在本连接之中，任何地方都可以使用（可以在结构内部，也可以跨库）

  会话变量可以在函数内部使用

  会话变量可以跨库

- 全局作用域

  所有的客户端所有的连接都有效：需要使用全局符号来定义

  set global 变量名=值

  set @@global.变量名=值

  通常，在SQL编程的时候，不会使用自定义变量来控制全局。一般都是定义会话变量或者在结构中使用局部变量来解决问题。

## 存储过程

- 概念

  > 一组为了完成特定功能的SQL语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译（效率比较高），用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中一个重要对象（针对SQL编程而言）。简称：过程

- 与函数的区别

  - 相同点

    存储过程和函数目的都是为了可重复地执行操作数据库的sql语句的集合。

    存储过程函数都是一次编译，后续执行

  - 不同点

    1. 标识符不同。函数标识符为FUNCTION，过程为：PROCEDURE。
    2. 函数中有返回值，且必须返回，而过程没有返回值
    3. 过程无返回值类型，不能将结果直接赋值给变量，函数有返回值类型，调用时，除在select中，必须将返回值赋给变量
    4. 函数可以在select语句中直接使用，而过程不能

- 存储过程操作

  1. 创建过程

     Create procedure 过程名字([参数列表])

     Begin 过程体 End结束符

     如果过程体中只有一条指令，那么可以省略begin end

  2. 查看过程

     查看过程与查看函数完全一样：除了关键字

     查看全部存储过程：show procedure status[like 'pattern']

  3. 调用过程

     过程：没有返回值，select 不可能调用

     调用过程有专门的语法：call 过程名([实参列表])

  4. 删除过程

     基本语法：drop procedure 过程名字

- 存储过程的形参类型

  存储过程也允许提供参数（形参和实参）：存储的参数也和函数一样，需要指定其类型。但是存储过程对参数还有额外的要求：自己的参数分类

  1. In

     表示参数从外部传入到里面使用（过程内部使用）：可以是直接数据也可以是保存数据的变量

  2. Out

     表示参数是从过程里面把数据保存到变量中，交给外部使用：传入的必须是变量

     如果说传入的out变量本身在外部有数据，那么在进入过程之后，第一件事就是被清空，设为NULL

  3. Inout

     数据可以从外部传入到过程内部使用，同时内部操作之后，又会将数据返还给外部。

     参数使用级别语法（形参）

     过程类型 变量名 数据类型; //int int_1 int

## 触发器

- 概念

  > 触发器是一种特殊类型的存储过程，不同于存储过程，它主要是通过事件进行触发而被执行，存储过程可以通过存储过程名字而被直接调用
  >
  > 触发器：trigger，是一种非常接近于js中的事件的知识。提前给某张表的所有记录（行）绑定一段代码，如果改行的操作满足条件（触发），这段提前准备好的代码就会自动执行

- 作用

  1. 可在写入数据表前，强制检验或转换数据。（保证数据安全）
  2. 触发器发生错误时，异动的结果会被撤销。（如果触发器执行错误，那么前面用户已经执行成功的操作也会被撤销：事务安全）
  3. 部分数据库管理系统可以针对数据定义语言（DDL）使用触发器，称为DDL触发器
  4. 可依照特定的情况，替换异动的指令（INSTEAD OF）(Mysql 不支持)

- 触发器优缺点

  优点：

  1. 触发器可通过数据库中的相关表实现级联更改。（如果某张表的数据改变，可以利用触发器来实现其他表的无痕操作[用户不知道]）、
  2. 保证数据安全：进行安全校验

  缺点：

  1. 对触发器过分依赖，势必影响数据库结构，同时增加了维护的复杂程度。
  2. 造成数据在程序层面不可控。

- 触发器基本语法

  1. 创建触发器

     > Create trigger 触发器名字 触发时机 触发事件 on 表 for each row
     >
     > Begin
     >
     > End

     触发对象：on 表 for each row，触发器绑定实质是表中的所有行，因此当每一行发生指定的改变，就会触发触发器

  2. 触发时机

     > 每张表中对应的行都会有不同的状态，当SQL指令发生的时候，都会令行中数据发生改变，每一行总会有两种状态：数据操作前和操作后

     Before：在表中数据发生改变前的状态

     After：在表中数据已经发生改变后的状态

  3. 触发事件

     > mysql中触发器针对的目标是数据发生改变，对应的操作只有写操作（增删改）
     >
     > Insert：插入操作
     >
     > Update：更新操作
     >
     > Delete：删除操作

  4. 注意事项

     一张表中，每一个触发时机绑定的触发事件对应的触发器类型只能有一个：一张表中只能由一个对应after insert 触发器

     因此，一张表中最多的触发器只能有6个：before insert、before update、before delete、after insert、after update、after delete

  5. 查看触发器 ---> show triggers\G

  6. 触发触发器

  7. 删除触发器  ---> drop trigger 触发器名字